package overFlow.Node;

import java.awt.Color;
import java.awt.Font;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java.lang.Object.*;
import java.util.Vector;

import com.sun.scenario.effect.DropShadow;
import com.sun.scenario.effect.InnerShadow;
import com.sun.scenario.scenegraph.SGGroup;
import com.sun.scenario.scenegraph.SGNode;
import com.sun.scenario.scenegraph.SGText;
import com.sun.scenario.scenegraph.SGTransform;
import com.sun.scenario.scenegraph.fx.FXShape;

public class Node{

  double tempx;
  double tempy;
  public float tx;
  public float ty;
  public float cx;
  public float cy;
  public float px;
  public float py;
  public float x;
  public float y;
  public float globalX;
  public float globalY;
  public float w;
  public float bw;
  public float h = 20;
  public int r;
  public Float value;
  public int outputs;
  public int inputs;
  public int outLockedID;
  public int inOrOut;
  public float mX, mY;
  public float xOffset, yOffset;
  public float outConnectionWidth;
  public float outConnectionGap;
  public float inConnectionGap;
  public float inConnectionWidth;
  public int counter = 0;

  int currentConnectionIDout;
  int currentConnectionIDin1;
  SGNode connectionOverNode;
  boolean connectionOver = false;
  //for interaction
  public boolean dragged = false;
  boolean press = false;
  boolean scaleable = true;
  boolean rollover;
  boolean locked;
  boolean over; 
  boolean highLight = false;
  private boolean scaling = false;
  public boolean connecting = false;
  private boolean scaleLocked = false;
  private boolean wideSelectionOnly = true;
  public boolean selected = false;
  private boolean buildConnections = true;
  private boolean paintStroke = true;
  public boolean movingSelected = false;

  Color strokeColor = new Color(150,150,150); 
  Color fillColor = new Color(50);
  Color borderColor = new Color(0xA5A5A5);
  Color highlightColor = new Color(205,255,240);  
  Color cfillColor = new Color(0xFFFFFF);
  Color cborderColor = new Color(0xA5A5A5);
  Color cHighlightColor = new Color(0xB9FFEB);
  String titleString;
  boolean outputConnectionPressed;

  OutputPort[] outputPorts;
  InputPort[] inputPorts;

  int currentInputConnectionID;

  Vector outputConnections  = new Vector();
  Vector inputConnections  = new Vector();
  public Float[] outputValues;
  public Float[] inputValues;  

  Point anchorGlobal = new Point();
  Point NMouseDragged;
  Point NMousePressedPos;
  private FXShape liner = new FXShape();
  public SGGroup subGroup = new SGGroup();
  SGText title = new SGText();
  SGGroup group = new SGGroup();
  private DropShadow shadow = new DropShadow();
  private InnerShadow iShadow = new InnerShadow();
  private FXShape baseRect = new FXShape(); 
  public SGTransform.Translate groupT = SGTransform.createTranslation(0, 0, group);

  Node currentObject;

  Connection activeConnection;
  String[] inputIDs;
  String[] outputIDs;

  float xVelocity = 0;
  float yVelocity = 0;
  float pMouseDraggedX;
  float pMouseDraggedY;
  float mouseDraggedX;
  float mouseDraggedY;
  float mousePressedX;
  float mousePressedY;
  float mouseMovedX;
  float mouseMovedY;

  boolean isInSelectionGroup = false;

  long oldTime;
  System nondeSys;
  Node() {
  }

  Node(String tTitle, float mx, float my, float tw, float th, int ins, int outs){
    inputs = ins;
    outputs = outs;
    titleString = tTitle;
    title.setText(titleString);
    rollover = false;
    locked = false;
    over = false; 
    x = mx;
    y = my;
    globalX = x;
    globalY = y;
    tempx = x;
    tempy = y;
    r = 8;
    w = tw;
    h = th;
    xOffset = 0;
    yOffset = 0;

    Rectangle2D rect;
    rect = title.getBounds();
    inputValues  = new Float[inputs];
    outputValues  = new Float[outputs];

    outputConnectionPressed = false;
    group.add(subGroup);
    group.add(createBox());
    group.add(createTitle());  
    createInputPorts();
    createOutputPorts();
    group.add(liner);

    constructor();
  }    



  Node(String tTitle, float mx, float my, int ins, int outs){
    inputs = ins;
    outputs = outs;
    titleString = tTitle;
    title.setText(titleString);
    rollover = false;
    locked = false;
    over = false; 
    x = mx;
    y = my;
    r = 8;  
    Rectangle2D rect;
    rect = title.getBounds();
    w = constrain((float)rect.getWidth() + 20, 20, 100000);

    inputValues  = new Float[inputs];
    outputValues  = new Float[outputs];

    outputConnectionPressed = false;
    group.add(subGroup);
    group.add(createBox());
    group.add(createTitle());  
    createInputPorts();
    createOutputPorts();
    group.add(liner);

    constructor();

  }

  SGNode returnGroup(){
    return groupT;
  }

  void createInputPorts(){
    inConnectionGap = (((w - 2 * r) / inputs)/2);
    inConnectionWidth = 6;

    inputPorts = new InputPort[inputs];
    float connectionWidth = 6;

    if(inputs == 2){
      inputPorts[0]= new InputPort(r + x, y, inConnectionWidth, thisObject(), 0);
      inputPorts[1]= new InputPort((x + w) - inConnectionWidth - r, y, inConnectionWidth, thisObject(), 1);
    }

    else{
      for(int i = 0; i < inputs; i++){
        inputPorts[i]= new InputPort(i * (inConnectionWidth + inConnectionGap) + r + x, y, inConnectionWidth, thisObject(), i);
      }    
    }
  }

  void createOutputPorts(){  
    outputPorts = new OutputPort[outputs]; 
    outConnectionGap = (((w - 2 * r) / outputs)/2);
    outConnectionWidth = 6;

    if(outputs == 2){
      outputPorts[0]= new OutputPort(r + x, y + h, outConnectionWidth, thisObject(), 0);
      outputPorts[1]= new OutputPort((x + w) - outConnectionWidth - r, y + h, outConnectionWidth, thisObject(), 1);
    }
    else{
      for(int i = 0; i < outputs; i++){
        outputPorts[i]= new OutputPort(i * (outConnectionWidth + outConnectionGap) + r + x, y + h, outConnectionWidth, thisObject(), i);
      }    
    }
  }


  SGNode createTitle(){
    title.setFont(new Font("Helvetica", Font.BOLD, 14));
    title.setLocation(new Point(int(x) + r, int(y) + 15));
    title.setAntialiasingHint(RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    title.setFillPaint(Color.GREEN);
    updateWidth();
    return title;
  }

  SGNode createBox(){
    SGGroup group = new SGGroup();   
    baseRect.setShape(new RoundRectangle2D.Float(0, 0, w, h, float(r), float(r)));
    baseRect.setTranslateX(x );
    baseRect.setTranslateY(y);
    baseRect.setFillPaint(new Color(fillColor));      
    baseRect.setMode(SGShape.Mode.STROKE_FILL); 
    baseRect.setDrawStroke(new BasicStroke(2.0f));
    baseRect.setDrawPaint(new Color(150,150,150));
    baseRect.setAntialiasingHint(RenderingHints.VALUE_ANTIALIAS_ON);
    //  baseRect.setEffect(shadow);
    baseRect.addMouseListener(new SGMouseAdapter() {
      Point pos;
      void mouseEntered(MouseEvent e, SGNode n) {
        FXShape node = (FXShape)n;
        over = true;
        objectOver = true;
        nodeOver();
        if(isInSelectionGroup){
          overSelection = true;
        }
      }
      void mouseMoved(MouseEvent e, SGNode n) {
        pos = e.getPoint();
        mX = pos.x;
        mY = pos.y;
        mouseMovedX = e.getX();
        mouseMovedY = e.getY();

      }      
      void mouseExited(MouseEvent e, SGNode n) {
        FXShape node = (FXShape)n;
        over = false;
        objectOver = false;
        nodeExited();
        if(isInSelectionGroup){
          overSelection = false;
        }

      }
      void mousePressed(MouseEvent e, SGNode n){
        FXShape node = (FXShape)n;
        pos = e.getPoint();
        nodePressed();
        mousePressedX = e.getX();
        mousePressedY = e.getY();
        if(editMode){

          //          updateConnections();
          if(nondeSys.nanoTime() - oldTime < 2.0000000E8) {
            if(selected){
              if(currentSelectedObjects.contains(this)){
                setSelected(false);
                currentSelectedObjects.remove(this);
              }
            }
            else {
              if(!currentSelectedObjects.contains(this)){
                setSelected(true); 
              }
            }
          }

        }
        oldTime = nondeSys.nanoTime();
      }
      void mouseReleased(MouseEvent e, SGNode n) { 
        dragged = false;
        nodeReleased();
      }
      void mouseDragged(MouseEvent e, SGNode n) {
        dragged = true;
        mouseDraggedX = e.getX();
        mouseDraggedY = e.getY();
        if(mouseDraggedX - mouseDraggedX < 100){
          xVelocity = mouseDraggedX - mouseDraggedX;
        }
        if(mouseDraggedY - pMouseDraggedY < 100){
          yVelocity = mouseDraggedY - pMouseDraggedY;
        }
        nodeDragged();
        if(editMode){
          if(pos != null) {
            if(!connectionOver) {
              NMouseDragged = e.getPoint();
              FXShape node = (FXShape)n;
              Point new_pos = e.getPoint();
              tx = new_pos.x - pos.x;
              ty = new_pos.y - pos.y;

              if(!movingSelected) {    //update location
                groupT.translateBy(tx, ty);
                setGlobal(tx,ty);
              }

              pos = new_pos;
              x += tx;
              y += ty;
              xOffset += tx;
              yOffset += ty;
              for(Iterator i = inputConnections.iterator(); i.hasNext();) {
                Connection con = (Connection)i.next();
                con.update();
              }
              for(Iterator i = outputConnections.iterator(); i.hasNext();) {
                Connection con = (Connection)i.next();
                con.update();
              }
            }
          }
        }
        pMouseDraggedX = e.getX();
        pMouseDraggedY = e.getY();
      }
    }
    );
    group.add(baseRect);
    return group;
  }

  void createShadow(){
    iShadow.setColor(new Color(255,255,255));
    iShadow.setRadius(5);
    shadow.setRadius(4);
    shadow.setOffsetX(2);
    shadow.setOffsetY(2);

  }
  void addShadow() {
    baseRect.setEffect(shadow);
  }

  private SGTransform createTranslation(SGNode node) {
    SGTransform toOriginT = SGTransform.createTranslation(-cx, -cy, node);
    SGTransform.Rotate rotateT = SGTransform.createRotation(0.0, toOriginT);
    SGTransform fromOriginT = SGTransform.createTranslation(cx, cy, rotateT);
    return fromOriginT;
  }

  // These are dead methods to be called when extending the basic Node for easy access to mouse events
  void nodeDragged(){
  }
  void nodeOver() {
  }
  void nodeExited(){
  }
  void nodePressed(){
  }
  void nodeReleased(){
  }

  void update() {          //updates inputValues to node values
    if(inputValues[0] != null) {
      value = inputValues[0];
      outputValues[0] = value;
      redrawNode();
      updateConnections(); 
    }
  }

  void updateConnections(){
    for(Iterator i = outputConnections.iterator(); i.hasNext();) {
      Connection con = (Connection)i.next();
      con.updateData();
    }
  }

  void updateConnectionLines() {
    for(Iterator i = inputConnections.iterator(); i.hasNext();) {
      Connection con = (Connection)i.next();
      con.update();
    }
    for(Iterator i = outputConnections.iterator(); i.hasNext();) {
      Connection con = (Connection)i.next();
      con.update();
    }
  }

  void updateWidth() {
    if(titleString.length() > 1){
      Rectangle2D rect;
      rect = title.getBounds();
      w = constrain((float)rect.getWidth() + r * 2, 40,1000);
      baseRect.setShape(new RoundRectangle2D.Float(0, 0, w, h, r, r));
    }
  }

  void updateInputValues() {
    outputValues[0] = inputValues[0];
    value = inputValues[0];
  }

  void redrawNode(){      //any scenario change redraws the scene graph
    groupT.translateBy(0,0);
    //update graphics here

  }

  void updateInputValue(int id, float value) {
    inputValues[id] = value;
    redrawNode();
    updateConnections();
  }


  void setGlobalX(float gx) {
    globalX += gx;
  }

  void setGlobalY(float gy) {
    globalY += gy;
  }
  
  void setGlobal(float gx, float gy) {
    globalX += gx;    
    globalY += gy;
  }

  float getGlobalX() {
    return globalX;
  }

  float getGlobalY() {
    return globalY;
  }


  float getOutputValue(int id) {
    float returnValue;
    if(outputValues[id] != null){
      returnValue = outputValues[id];
    }
    else {
      returnValue = 0;
    }  
    return returnValue;
  }

  void addToGroup(SGGroup groupToAdd) {
    group.add(groupToAdd);
  }

  Point2D returnLocation() {
    Point2D p = new Point2D.Double(x, y);
    return p;
  }
  void setSelected(boolean s) {
    selected = s;
    if(selected) {
      baseRect.setFillPaint(new Color(200,200,200,150)); 
      if(!currentSelectedObjects.contains(this)){
        currentSelectedObjects.add(this); 
      }
    }
    else {
      baseRect.setFillPaint(new Color(fillColor));
      currentSelectedObjects.remove(this);
    }  
  }

  public void deselect(){
    selected = false;
    currentSelectedObjects.remove(this);
  }


  void killConnections(){
    for(Iterator i = outputConnections.iterator(); i.hasNext();) {
      Connection con = (Connection)i.next();
      rootGroup.remove(con.returnGroup()); 
    }
    for(Iterator i = inputConnections.iterator(); i.hasNext();) {
      Connection con = (Connection)i.next();
      rootGroup.remove(con.returnGroup()); 
    }
    println(outputConnections.size());

  } 

  void constructor(){
  }

  float getX() {
    return x;
  }
  float getY() {
    return y;
  }

  Node thisObject() {
    return this;
  }
}

































































































































